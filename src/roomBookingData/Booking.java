package roomBookingData;

import java.io.Serializable;
import java.time.LocalDate;
import java.util.ArrayList;
import java.util.List;


/**
 * <h1>Booking</h1> 
 * Manages the booking and comparing against other bookings.
 * 
 * <p>
 * Checks if a room is booked, if a room is booked returns false.
 * 
 * @author Gareth Tucker
 * @version 0.1.3
 * @since 07-06-2019
 */
public class Booking implements Comparable<Booking>, Serializable
{
    /**
     * suppress warnings added variables may get used in a future update.
     */
    private static final long serialVersionUID = 1L;
    private int roomNum;
    private LocalDate date;
    private int endTime;
    private int startTime;
    @SuppressWarnings("unused")
    private int workStat;
    @SuppressWarnings("unused")
    private int breakout;
    @SuppressWarnings("unused")
    private boolean smart;
    @SuppressWarnings("unused")
    private boolean print;
    private int bookingCounter;
    private int clientCounter;

    /**
     * Constructor creates booking for comparing
     * 
     * @param bookingCounter system generated property.
     * @param clientCounter system generated property.
     * @param roomNum room number generated by best room.
     * @param date  user selected date.
     * @param startTime  start time of booking.
     * @param endTime end time of booking.
     * @param workStat number of workstations selected by user.
     * @param breakout number of breakout chairs selected by user.
     * @param smart true if required, false if not.
     * @param print true if required, false if not.
     */
    public Booking(int bookingCounter, int clientCounter, int roomNum, LocalDate date, int startTime, int endTime,
            int workStat, int breakout, Boolean smart, Boolean print)
    {
        this.roomNum = roomNum;
        this.date = date;
        this.startTime = startTime;
        this.endTime = endTime;
        this.workStat = workStat;
        this.breakout = breakout;
        this.smart = smart;
        this.print = print;
        this.bookingCounter = bookingCounter;
        this.setClientCounter(clientCounter);
    }

    /**
     * Method to compare current booking time and date and room. if the booking
     * is possible true is returned to the calling method. if the booking is not
     * possible false is returned to the calling method. Steps. Checks room
     * number is a match if a match occurs. Checks date of booking if a match
     * occurs. Checks time of booking. Checks for start time match - checks the
     * start time required against the start time entered. Checks for start time
     * lower than current end time - returns false as within time slot of
     * previous booking. Checks if start time is equal to the end time --
     * returns true as new slot available.
     * 
     * @param roomNum required to check against existing bookings.
     * @param date required to check against date supplied by user.
     * @param startTime required to check against start time supplied by user.
     * @param endTime required to check against end time supplied by user.
     * @param bookingList list of bookings currently stored.
     * @return return boolean true or false.
     */
    public static boolean roomBooked(int roomNum, LocalDate date, int startTime, int endTime, List<Booking> bookingList)
    {
        for (int i = 0; i < bookingList.size(); i++) {
            Booking b = bookingList.get(i);
            int roomNum2 = b.getRoomNum();

            if (roomNum2 == roomNum) {
                LocalDate date2 = b.getDate();
                if (date2.equals(date)) {
                    int start = b.getStartTime();
                    int end = b.getEndTime();
                    if (start == startTime) {

                        return false;
                    }
                    if (startTime < end) {
                        return false;
                    }
                    if (startTime == end) {
                        return true;
                    }
                }
            }
        }
        return true;

    }

    /**
     * Removes booking where client ID matches an id in the booking list
     * 
     * @param clientID user supplied entry
     * @param bookingList Array list of bookings.
     */
    public static void cancelBooking(int clientID, List<Booking> bookingList)
    {
        List<Booking> toRemove = new ArrayList<Booking>();

        for (int i = 0; i < bookingList.size(); i++) {
            Booking bk = bookingList.get(i);
            int id = bk.getClientCounter();

            if (id == clientID) {
                toRemove.add(bk);
            }
            bookingList.removeAll(toRemove);
            DataProcess.writeBookingObjects();
        }
    }

    /**
     * @return the roomNum
     */
    private int getRoomNum()
    {
        return roomNum;
    }

    /**
     * @return the date
     */
    protected LocalDate getDate()
    {
        return date;
    }

    /**
     * @param date // the date to set
     */
    protected void setDate(LocalDate date)
    {
        this.date = date;
    }

    /**
     * @return the startTime
     */
    protected int getStartTime()
    {
        return startTime;
    }

    /**
     * @param startTime // the startTime to set
     */
    protected void setStartTime(int startTime)
    {
        this.startTime = startTime;
    }

    /**
     * @return the endTime
     */
    protected int getEndTime()
    {
        return endTime;
    }

    /**
     * @param endTime // the endTime to set
     */
    protected void setEndTime(int endTime)
    {
        this.endTime = endTime;
    }

    /**
     * @return the clientCounter
     */
    private int getClientCounter()
    {
        return clientCounter;
    }

    /**
     * @param clientCounter // the clientCounter to set
     */
    private void setClientCounter(int clientCounter)
    {
        this.clientCounter = clientCounter;
    }

    /**
     * To string method
     */
    @Override
    public String toString()
    {
        StringBuilder sb = new StringBuilder();

        sb.append("[ Ref = \"");
        sb.append(bookingCounter);
        sb.append("\" ,\nClient ID = \"");
        sb.append(getClientCounter());
        sb.append("\" ,\nRoom Number = \"");
        sb.append(roomNum);
        sb.append("\" ,\nDate = \"");
        sb.append(date);
        sb.append("\" ,\nDuration= \"");
        sb.append((endTime/100 - startTime/100 ));
        sb.append(" ");
        sb.append("]\n");

        return sb.toString();
    }

    /**
     * compare to method
     */
    @Override
    public int compareTo(Booking o)
    {
        return 0;
    }

}